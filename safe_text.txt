getItem("orders"); return X ? JSON.parse(X) : ow }), [n, i] = Re.useState(() => { const X = localStorage.getItem("clients"); return X ? JSON.parse(X) : h2 }), [s, o] = Re.useState(() => { const X = localStorage.getItem("years"), ce = ["2023", "2024", "2025"]; return X ? JSON.parse(X) : ce }), [l, f] = Re.useState(() => { const X = localStorage.getItem("objectives"); return X ? JSON.parse(X) : ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"].reduce((oe, ae) => (oe[ae] = { obj3: "", obj4: "", obj5: "" }, oe), {}) }), [h, d] = Re.useState(() => { const X = localStorage.getItem("yearlySales"); if (X) return JSON.parse(X); const ce = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], oe = {}; return ce.forEach(ae => { oe[ae] = {}, s.forEach(ve => { oe[ae][ve] = "" }) }), oe }), [p, x] = Re.useState(() => { const X = localStorage.getItem("realBilling"); if (X) return JSON.parse(X); const ce = ["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], oe = {}; return ce.forEach(ae => { oe[ae] = {}, s.forEach(ve => { oe[ae][ve] = "" }) }), oe }), [_, A] = Re.useState(() => localStorage.getItem("lastReportDate") || ""), [v, S] = Re.useState(() => localStorage.getItem("googleScriptUrl_v2") || "https://script.google.com/macros/s/AKfycbyVYxW9uXRPIANntN4rwZ4mmEEEnEwVMEJ6g1oIpm93Fn4Q6iAy9vuGEpBD0g3AWcCT/exec"); Re.useEffect(() => { localStorage.setItem("orders", JSON.stringify(t)) }, [t]), Re.useEffect(() => { localStorage.setItem("clients", JSON.stringify(n)) }, [n]), Re.useEffect(() => { localStorage.setItem("objectives", JSON.stringify(l)) }, [l]), Re.useEffect(() => { localStorage.setItem("yearlySales", JSON.stringify(h)) }, [h]), Re.useEffect(() => { localStorage.setItem("realBilling", JSON.stringify(p)) }, [p]), Re.useEffect(() => { localStorage.setItem("years", JSON.stringify(s)) }, [s]), Re.useEffect(() => { localStorage.setItem("lastReportDate", _) }, [_]), Re.useEffect(() => { localStorage.setItem("googleScriptUrl_v2", v) }, [v]); const w = async (X, ce) => { if (!v) return { success: !1, error: "No Script URL configured" }; let oe = { ...X, type: ce }; if (ce === "ORDER" || ce === "UPDATE") { const ae = n.find(ve => { var ne, Y; return ((ne = ve.name) == null ? void 0 : ne.toLowerCase().trim()) === ((Y = X.clientName) == null ? void 0 : Y.toLowerCase().trim()) }); oe.city = (ae == null ? void 0 : ae.city) || "", oe.province = (ae == null ? void 0 : ae.province) || "", oe.facturado = X.facturadoTodo ? "SÝ" : X.facturadoSinTampo ? "Parcial" : "No" } try { const ae = await fetch(v, { method: "POST", cache: "no-cache", credentials: "omit", headers: { "Content-Type": "text/plain;charset=utf-8" }, redirect: "follow", referrerPolicy: "no-referrer", body: JSON.stringify(oe) }); return ae.ok || ae.type === "opaque" ? (console.log("Synced to Google Sheets:", ce, ae.status), { success: !0 }) : (console.error("Sync responded with error:", ae.status), { success: !1, error: `Server Error: ${ae.status} ${ae.statusText}` }) } catch (ae) { return console.error("Sync failed network/cors:", ae), { success: !1, error: `Network Error: ${ae.message}` } } }, T = (X, ce, oe) => { f(ae => ({ ...ae, [X]: { ...ae[X], [ce]: oe } })) }, y = (X, ce, oe) => { d(ae => ({ ...ae, [X]: { ...ae[X], [ce]: oe } })) }, C = (X, ce, oe) => { x(ae => ({ ...ae, [X]: { ...ae[X], [ce]: oe } })) }, D = () => { o(X => { const oe = (Math.max(...X.map(ae => parseInt(ae))) + 1).toString(); return d(ae => { const ve = { ...ae }; return Object.keys(ve).forEach(ne => { ve[ne] = { ...ve[ne], [oe]: "" } }), ve }), x(ae => { const ve = { ...ae }; return Object.keys(ve).forEach(ne => { ve[ne] = { ...ve[ne], [oe]: "" } }), ve }), [...X, oe] }) }, b = X => { const ce = { ...X, id: X.id || (t.length > 0 ? Math.max(...t.map(oe => oe.id)) + 1 : 900), timestamp: new Date().toISOString() }; r([ce, ...t]), w(ce, "ORDER") }, O = X => { r(ce => ce.map(oe => String(oe.id) === String(X.id) ? X : oe)), w(X, "UPDATE") }, V = X => { r(ce => ce.filter(oe => String(oe.id) !== String(X))) }, z = async () => { if (!v) return { success: !1, error: "Configuraci¾n incompleta" }; const X = Object.values(l).every(ce => !ce.obj3 && !ce.obj4 && !ce.obj5); t.length === 0 && X && console.warn("Backup aborted: Data seems to be empty/cleared."); try { const ce = { orders: t, clients: n, years: s, objectives: l, yearlySales: h, realBilling: p, metadata: { generatedAt: new Date().toISOString(), version: "2.0", device: navigator.userAgent } }, oe = await fetch(v, { method: "POST", mode: "no-cors", cache: "no-cache", headers: { "Content-Type": "text/plain;charset=utf-8" }, body: JSON.stringify({ action: "backup", dateStr: new Date().toISOString().split("T")[0], payload: ce }) }); return console.log("Backup sent to Drive"), { success: !0 } } catch (ce) { return console.error("Backup failed:", ce), { success: !1, error: ce.message } } }, H = async () => { if (!v) return { success: !1, error: "Configuraci¾n incompleta" }; try { return await (await fetch(v, { method: "POST", headers: { "Content-Type": "text/plain;charset=utf-8" }, redirect: "follow", body: JSON.stringify({ action: "listBackups" }) })).json() } catch (X) { return { success: !1, error: X.message } } }, K = async X => { if (!v) return { success: !1, error: "Configuraci¾n incompleta" }; try { const oe = await (await fetch(v, { method: "POST", headers: { "Content-Type": "text/plain;charset=utf-8" }, redirect: "follow", body: JSON.stringify({ action: "getBackup", fileId: X }) })).json(); if (oe.result === "success" && oe.payload) { const ae = oe.payload; return ae.orders && r(ae.orders), ae.clients && i(ae.clients), ae.years && o(ae.years), ae.objectives && f(ae.objectives), ae.yearlySales && d(ae.yearlySales), ae.realBilling && x(ae.realBilling), { success: !0 } } return { success: !1, error: "No payload found" } } catch (ce) { return { success: !1, error: ce.message } } }, G = async X => { if (!v) return { success: !1, error: "Configuraci¾n incompleta" }; try { const oe = await (await fetch(v, { method: "POST", headers: { "Content-Type": "text/plain;charset=utf-8" }, redirect: "follow", body: JSON.stringify({ action: "deleteBackup", fileId: X }) })).json(); return oe.result === "success" ? { success: !0 } : { success: !1, error: oe.error || "Error desconocido" } } catch (ce) { return { success: !1, error: ce.message } } }; return g.jsx(d2.Provider, { value: { orders: t, clients: n, objectives: l, updateObjective: T, yearlySales: h, updateYearlySale: y, realBilling: p, updateRealBilling: C, addOrder: b, updateOrder: O, deleteOrder: V, setClients: i, setOrders: r, years: s, addNewYear: D, lastReportDate: _, setLastReportDate: A, scriptUrl: v, setScriptUrl: S, syncToGoogle: w, uploadBackupToDrive: z, listBackupsFromDrive: H, restoreBackupFromDrive: K, deleteBackupFromDrive: G, setObjectives: f, setYearlySales: d, setRealBilling: x }, children: e }) };/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var cw = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const fw = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim(), Je = (e, t) => { const r = Re.forwardRef(({ color: n = "currentColor", size: i = 24, strokeWidth: s = 2, absoluteStrokeWidth: o, className: l = "", children: f, ...h }, d) => Re.createElement("svg", { ref: d, ...cw, width: i, height: i, stroke: n, strokeWidth: o ? Number(s) * 24 / Number(i) : s, className: ["lucide", `lucide-${fw(e)}`, l].join(" "), ...h }, [...t.map(([p, x]) => Re.createElement(p, x)), ...Array.isArray(f) ? f : [f]])); return r.displayName = `${e}`, r };/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const uw = Je("AlertCircle", [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]]);/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const hw = Je("AlertTriangle", [["path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z", key: "c3ski4" }], ["path", { d: "M12 9v4", key: "juzpu7" }], ["path", { d: "M12 17h.01", key: "p32p05" }]]);/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const dw = Je("ArrowRight", [["path", { d: "M5 12h14", key: "1ays0h" }], ["path", { d: "m12 5 7 7-7 7", key: "xquz4c" }]]);/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mw = Je("ArrowUpRight", [["path", { d: "M7 7h10v10", key: "1tivn9" }], ["path", { d: "M7 17 17 7", key: "1vkiza" }]]);/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const pw = Je("Award", [["circle", { cx: "12", cy: "8", r: "6", key: "1vp47v" }], ["path", { d: "M15.477 12.89 17 22l-5-3-5 3 1.523-9.11", key: "em7aur" }]]);/**
 * @license lucide-react v0.314.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the
